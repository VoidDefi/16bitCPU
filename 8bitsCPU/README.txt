Это 16битный процессор, просто мне было лень его переименовывать.

Как работать с этим?
  1. Скачиваем код с репазитория
  2. Откываем решение в Visual Studio
  3. Собираем решение и запускаем проекты, потом закрываем, если процессор выдал ошибку - это нормально, диска пока нету
  4. Открываем корневую папку решения через проводник
  5. Открываем Compiler\bin\Debug\net6.0
  6. В папке Files создаём файл Code.asm или с другим именем
  7. Открываем этот файл
  8. Теперь можно писать код
  9. После сохранения открываем Compiler.exe, вводин имя вашего кода, потом, в другом поле, эти буквы: "HD"
  10. Теперь можно открывать 8bitCPU.exe в этой же папке и можем смотреть на результат.

Инструкции:
    MOV' Register, Address  : (1)  перемещает значения из сегмента данных ОЗУ в регистр.                          (Move) +
    MOV' Address, Register  : (2)  перемещает значения из регистра в сегмент данных ОЗУ.                          (Move) +
    ADD' Register, Register : (3)  складывает два числа, ответ записывает в регистр первого операнда.             (Add) +
    ADD' Register, Number   : (4)  складывает два числа, ответ записывает в регистр.                              (Add) +
    SUB' Register, Register : (5)  вычитает два числа, ответ записывает в регистр первого операнда.               (Sub) +
    SUB' Register, Number   : (6)  вычитает два числа, ответ записывает в регистр.                                (Sub) +
       '                    : (7)                                                                                 (   )
    NLN' Register, Number   : (8)  вывод в консоль байт. если Namber 0, то числом, если 1, то символом.           (New line Note) +
    NLN' Number, Number1    : (9)  вывод в консоль байт.  если Namber1 0, то числом, если 1, то символом.         (New line Note) +
    NLN' Address, Number    : (10) вывод в консоль байт.  если Namber 0, то числом, если 1, то символом.          (New line Note) +
    MVC' Address,           : (11) передвигает каретку на адрес (сегмента Кода) в первом операнде.                (Move carriage) +
    MBC'                    : (12) передвигает каретку в место откуда её переместили.                             (Move back carriage) +
    END'                    : (13) выход из программы.                                                            (End) +
    MOV' Register, Number   : (14) перемещает число в регистр.                                                    (Move) +
    MOV' Address, Number    : (15) перемещает число в сегмент данных ОЗУ.                                         (Move) +
    AND' Register, Register : (16) побитовое логическое умножение, результат записывает в первый регистр.         (And) +
    ORL' Register, Register : (17) побитовое логическое сложение, результат записывает в первый регистр.          (Or logic) +
    XOR' Register, Register : (18) побитовое исключающее ИЛИ, результат записывает в первый регистр.              (Xor) +
    NOT' Register           : (19) побитовое логическое отрицание, результат записывает в первый регистр.         (Not) +
    SHR' Register, Register : (20) побитовый сдвиг вправо, результат записывает в первый регистр.                 (Shift Right) +
    SHR' Register, Number   : (21) побитовый сдвиг вправо, результат записывает в первый регистр.                 (Shift Right) +
    SHL' Register, Register : (22) побитовый сдвиг влево, результат записывает в первый регистр.                  (Shift Left) +
    SHL' Register, Number   : (23) побитовый сдвиг влево, результат записывает в первый регистр.                  (Shift Left) +
    IFL' Register, Register : (24) Проверка операндов, но результат записывает в один из 4 флагов.                (If Logic) +
    IFL' Register, Address  : (25) Проверка операндов, но результат записывает в один из 4 флагов.                (If Logic) +
    IFL' Address, Address   : (26) Проверка операндов, но результат записывает в один из 4 флагов.                (If Logic) +
    FLS'                    : (27) Выполняет инструкцию под ним, если FalseFlag == true, иначе, пропускает её.    (False) +
    TRE'                    : (28) Выполняет инструкцию под ним, если TrueFlag == true, иначе, пропускает её.     (True) +
    MOR'                    : (39) Выполняет инструкцию под ним, если MoreFlag == true, иначе, пропускает её.     (More) +
    LES'                    : (30) Выполняет инструкцию под ним, если LessFlag == true, иначе, пропускает её.     (Less) +
    BIR' Number, Number     : (31) Выполняет BIOS команду из 1 операнда. (Подробнее в разделе: BIOS команды)      (BIOS Instruction) +
    DMD' Register, Register : (32) Перемещает Данные из ячейки данных по адресу из регистра 2 операнда в регистр. (Dynamically move data) +
    DMD' Address, Register  : (33) Перемещает Данные из ячейки данных по адресу из регистра 2 операнда в память.  (Dynamically move data) +
    MOV' Register, Register : (34) Перемещает значения из регистра 2 в регистр 1.                                 (Move) +
    IFL' Register, Number   : (35) Проверка операндов, но результат записывает в один из 4 флагов.                (If Logic) +

Удалённые инструкции:
    ALM' Data               : (7)  выделяет адрес в памяти, для значения, не будет использоваться пользователями. (Allocate memory) (Некогда не использовалась, окозалась безсмысленной)

Регистры:
    DT : (0) Регистр данных         (стандартный, 16 бит), (Data)          ╮
    IR : (1) Регистр инструкций     (стандартный, 16 бит), (Instructions)  │
    AF : (2) Регистр арифметический (стандартный, 16 бит), (Arithmetic)    │
    CT : (3) Регистр счётчик        (стандартный, 16 бит), (Counter)       │
                                                                           ╞   (Рабочие, можно получить доступ из программы)    
    GR : (4) Регистр общий          (стандартный, 16 бит), (Generic)       │
    CM : (5) Регистр общий          (стандартный, 16 бит), (Common)        │
    JN : (6) Регистр общий          (стандартный, 16 бит), (Joint)         │
    MT : (7) Регистр общий          (стандартный, 16 бит), (Mutual)        ╯
    
   lIR : (x) Регистр инструкций     (расширенный, 40 бит), (Long Instructions) (Системный, нельзя получить доступ из программы) 

BIOS Регистры:
    BX : (8) Регистр абсциссы       (стандартный, 16 бит), (Bios X) 
    BY : (9) Регистр ординаты       (стандартный, 16 бит), (Bios Y) 

BIOS команды:
    Display Draw  : (0) рисует пиксель. BX и BY - его координаты.
    Display Clear : (1) Очищает экран.

Флаги:
    FalseFlag : логический флаг. будет истиной, если два байта не ровны.             можно изменить, инструкция IFL' можно получить, инструкция FLS'
    TrueFlag  : логический флаг. будет истиной, если два байта ровны.                можно изменить, инструкция IFL' можно получить, инструкция TRE'
    MoreFlag  : логический флаг. будет истиной, если один байт будет больше другого. можно изменить, инструкция IFL' можно получить, инструкция MOR'
    LessFlag  : логический флаг. будет истиной, если один байт будет меньше другого. можно изменить, инструкция IFL' можно получить, инструкция LES'
    FlagQuit  : системный флаг.  служит для остановки программы.                     можно изменить, инструкция END'

Типы Адресации:
    0a0d[адрес] : адресатор. адресация к сегменту данных. [] - не нужны; адрес - номер ячейки в памяти (отчёт начинается с 0) 
    0a0c[адрес] : адресатор. адресация к сегменту кода.   [] - не нужны; адрес - номер ячейки в памяти (отчёт начинается с 0) 

Конкретизаторы:
    ?char:[символ]     : конкретизатор. [] - не нужны;                          символ - знак, который при компиляции преобразуется в число, в зависимости от таблицы ASCII;
    ?char/u:[символ]   : конкретизатор. [] - не нужны; /u   - верхний регистр;  символ - знак, который при компиляции преобразуется в число, в зависимости от таблицы ASCII;
    ?char/d:[символ]   : конкретизатор. [] - не нужны; /d   - нижний регистр;   символ - знак, который при компиляции преобразуется в число, в зависимости от таблицы ASCII;
    ?char/esc:[символ] : конкретизатор. [] - не нужны; /esc - 0 a b t n v f r;  символ - знак, который при компиляции преобразуется в число, в зависимости от таблицы ASCII;

Синтаксис:
    Каждая команда обязана писаться с новой строки, но любые пробелы и горизонтальные табуляции, даже между символами, будут удалятся при компиляции и весь код переведётся в нижний регистр.
    Весь код должен писаться после "code:", и до конца файла или до "data:" (в последнее пока нельзя добавить переменные).

    Комментарии:
        Комментарии начинаются с ";", а многострочных нету.

    Инструкции:
        существует 3 записи инструкции:

         без операндов:     инс' или инс
         с одним операндом: инс' операнд1 
         с двумя операндом: инс' операнд1, операнд2

        и 4 вида операндов:

         Register         - регистр
         Address [данных] - адрес, для уточнения: 0a0d[адрес]
         Address [кода]   - адрес, для уточнения: 0a0с[адрес]
         Number           - число, любой конкретизатор, переводит значение в число 

    Метки: 
        метки нужны для более удобных прыжков по коду.

        метка должна начинаться с точки ".label". они ставятся перед нужным блоком кода.
        а для вызова метки, нужно использовать инструкцию MVC', и в качестве операнда взять имя метки взятое в тильды:

        ```mvc' ~label~```

    Примеры кода:
        Калькулятор:

        ```
        code:
          mov' AF, 10 ;перемещение 10 в AF
          mov' DT, 40 ;перемещение 40 в DT
          add' AF, DT ;сложение двух чисел.

          nln' AF, 0 ;вывод в консоль

          end' ;выход из программы
        ```
        Этот код перемещает 10 и 40 в регистры AF и DT, соответственно 
        и складывает их в "add'", результат операции сохраняется в регистре AF

        Ветвления, условия:

        ```
        code:
          mov' AF, 10 ;перемещение 10 в AF
          mov' DT, 40 ;перемещение 40 в DT

          ifl' AF, DT ;сравнение
            tre';если истина
              mvc' ~if~ ;прыжок к метки 

            fls' ;если ложь
              mvc' ~else~ ;прыжок к метки 

          .if
            ;код
            end' ;выход из программы

          .else 
            ;код
            end' ;выход из программы
        ```

        Здесь происходит сравнение двух регистров, результаты которого записаны в 4 флага (FalseFlag, TrueFlag, MoreFlag, LessFlag)
        tre' проверяет на истину флаг "TrueFlag", если истина, то выполняется инструкция под ним, в противном случае происходит микро прыжок
        на следующую инструкцию. Аналогично и с fls'

        Циклы:

        while:
            ```
            code:
              mov' DT, 1

              .loop 

              ifl' DT, 1
                tre' ;проверка на истину 
                  mvc' ~loop~ ;зацикливание

              end'
            ```

        for:
            ```
            code:
              .loop

              add' CT, 1 ;увеличение счётчика

              ifl' CT, 10
                les' ;проверка на максимум счётчика
                  mvc' ~loop~ ;зацикливание

              end'
            ```

        Hello World!:

        ```
        code:
          nln' ?char/u: H, 1 ;Вывод строки побуквенно
          nln' ?char/d: e, 1
          nln' ?char/d: l, 1
          nln' ?char/d: l, 1
          nln' ?char/d: o, 1
          nln'         32, 1
          nln' ?char/u: W, 1
          nln' ?char/d: o, 1
          nln' ?char/d: r, 1
          nln' ?char/d: l, 1
          nln' ?char/d: d, 1
          nln' ?char:   !, 1
        ```

        или 

        ```
        code:
          mov' 0a0d0,  ?char/u: H ;Перенос строки в память
          mov' 0a0d2,  ?char/d: e ;
          mov' 0a0d4,  ?char/d: l ;
          mov' 0a0d6,  ?char/d: l ;
          mov' 0a0d8,  ?char/d: o ;
          mov' 0a0d10,         32 ;
          mov' 0a0d12, ?char/u: W ;
          mov' 0a0d14, ?char/d: o ;
          mov' 0a0d16, ?char/d: r ;
          mov' 0a0d18, ?char/d: l ;
          mov' 0a0d20, ?char/d: d ;
          mov' 0a0d22, ?char:   ! ;

          mov' GR, 12 ;запись длины строки
          add' GR, GR ;умножения на 2

          .loop

            dmd' DT, AF ;берём адрес из AF, ищем данные в памяти и записываем их в DT

            add' AF, 2 ;изменяем адрес

            nln' DT, 1;

            ifl' AF, GR 
              tre'
                end'
              fls'
                mvc ~loop~
        ```

        Вывод пикселя:

        ```
        code:
          bir' 1, 0 ;очистка экрана

          mov' BX, 2 ;позиция пикселя по X
          mov' BY, 2 ;позиция пикселя по Y
          bir' 0, 0 ;рисуем пиксель

        ```


Опкоды:
    Этот компьютер имеет фиксированную длину опкодов, которая равна 5 байтам.

    1 байт     - номер инструкции.
    2 и 3 байт - операнд1.
    4 и 5 байт - операнд2.

    в памяти может быть не более 13107.2 инструкций.

Файл диска HD.rmy:
    Этот файл представляет собой загрузочный диск компьютера.
    Диск - тоже имеет 2 сегмента как и ОЗУ: данных и кода.

    в первых 65536 байтах - хранится сегмент данных,
    а во вторых 65536 байтах - сегмент кода.
